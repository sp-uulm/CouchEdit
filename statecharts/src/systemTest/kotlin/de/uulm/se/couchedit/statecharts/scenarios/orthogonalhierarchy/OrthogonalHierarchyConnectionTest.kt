package de.uulm.se.couchedit.statecharts.scenarios.orthogonalhierarchy

import com.google.common.collect.Table
import de.uulm.se.couchedit.model.base.Element
import de.uulm.se.couchedit.model.base.ElementReference
import de.uulm.se.couchedit.model.compartment.CompartmentHotSpotDefinition
import de.uulm.se.couchedit.model.graphic.ShapedElement
import de.uulm.se.couchedit.model.graphic.elements.PrimitiveGraphicObject
import de.uulm.se.couchedit.model.graphic.shapes.Label
import de.uulm.se.couchedit.model.graphic.shapes.Shape
import de.uulm.se.couchedit.processing.common.repository.ServiceCaller
import de.uulm.se.couchedit.processing.spatial.services.geometric.JTSGeometryProvider
import de.uulm.se.couchedit.processing.spatial.services.geometric.ShapeExtractor
import de.uulm.se.couchedit.statecharts.model.couch.elements.State
import de.uulm.se.couchedit.statecharts.model.couch.elements.StateChartAbstractSyntaxElement
import de.uulm.se.couchedit.statecharts.model.couch.relations.ParentOf
import de.uulm.se.couchedit.statecharts.model.couch.relations.Transition
import de.uulm.se.couchedit.statecharts.model.couch.relations.representation.LabelFor
import de.uulm.se.couchedit.statecharts.model.couch.relations.representation.LabelForHierarchyElement
import de.uulm.se.couchedit.statecharts.model.couch.relations.representation.Represents
import de.uulm.se.couchedit.statecharts.model.couch.relations.representation.transition.RepresentsTransition
import de.uulm.se.couchedit.statecharts.scenarios.BaseStatechartScenario
import de.uulm.se.couchedit.statecharts.testdata.OrthogonalStateLineRepresentation
import de.uulm.se.couchedit.statecharts.testdata.SplittingOrthogonalStateLineGenerator
import de.uulm.se.couchedit.statecharts.testdata.SplittingOrthogonalStateLineGenerator.SplitResult
import de.uulm.se.couchedit.statecharts.testdata.StateRepresentationGenerator
import de.uulm.se.couchedit.statecharts.testdata.StateRepresentationGenerator.StateRepresentation
import de.uulm.se.couchedit.statecharts.testdata.StateTransitionGenerator
import de.uulm.se.couchedit.statecharts.testdata.StateTransitionGenerator.TransitionRepresentation
import de.uulm.se.couchedit.statecharts.testmodel.OrthogonalHierarchyConnectionTestDetails
import de.uulm.se.couchedit.systemtestutils.test.SystemTestProcessor
import de.uulm.se.couchedit.testsuiteutils.annotation.CouchEditSuiteTest
import de.uulm.se.couchedit.testsuiteutils.model.TestInstanceInfo
import de.uulm.se.couchedit.testsuiteutils.testdata.grid.GridAreasGenerator.Area
import de.uulm.se.couchedit.util.extensions.ref
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.Order
import org.locationtech.jts.geom.prep.PreparedGeometry
import org.locationtech.jts.geom.prep.PreparedGeometryFactory

/**
 * Test scenario that checks the correctness of interpretation of state representations nested
 * in different hierarchy elements and the correct comprehension of all [Transition] Elements between them.
 *
 * This also has the purpose of checking the performance when interpreting "realistically-sized" diagrams with a modest
 * amount of states and transitions.
 *
 * The initial situation looks like this (this is duplicated [size] times). Note that it does not represent a syntactically
 * correct statechart (e.g. there may not be transitions between members of different orthogonal regions of the same parent
 * state) but this is on purpose - to check syntax in the future, incorrect syntax must also be able to be recognized as-is.
 *
 * Note that the connections are not routed exactly as displayed, but generated by the [StateTransitionGenerator].
 *
 * ~~~
 * +--------+      +--------+
 * |        |      |        |
 * |   1A   |      |   1B   |
 * |        |      |        |
 * +--+-----+ +----+--------+
 *    |       |
 *    v       |
 * +--+----------+   +--------------+
 * |  1C      |  |   | 1D           |
 * |          v  |   |              |
 * |  +-------++ |   |  +---------+ |
 * |  |        | |   |  |         | |
 * |  |  1CA   +------->+   1DA   +----------+
 * |  |        | |   |  |         | |        |
 * |  +----+---+ |   |  +-+-------+ |        |
 * |       |     |   |    ^         |        |
 * |       v     |   |    |         |        |
 * |  +----+---+ |   |    |         |        |
 * |  |        | |   |    |         |        |
 * |  |  1CB   | |   |    |         |        |
 * |  |        | |   |    |         |        v
 * |  +----+---+ |   |    |         |     +--+-----+
 * |       |     |   |    |         |     |        |
 * +-------------+   +--------------+     |   1F   |
 *         |              |               |        |
 *         |              |               +--+-----+
 * +--------------------------------+        |
 * | 1EA   |      X       | 1EB     |        |
 * |       v              |         |        |
 * |  +----+---+  X   +---+----+    |        |
 * |  |        |      |        |    |        |
 * |  |  1EAA  +----->+  1EBA  +<------------+
 * |  |        |      |        |    |
 * |  +---+----+  X   +--------+    |    +-----------------------+
 * |      |                         |    | 1GA       X  1GB      |
 * |      v       X                 |    |                       |
 * |  +---+----+      +--------+    |    |  +------+ X  +------+ |
 * |  |        |  X   |        |    |    |  |      |    |      | |
 * |  |  1EAB  |      |  1EBB  +----------->+ 1GAA | X  | 1GBA | |
 * |  |        |  X   |        |    |    |  |      |    |      | |
 * |  +---+----+      +--------+    |    |  +------+ X  +------+ |
 * |      |       X                 |    |                       |
 * +------|-------------------------+    +-----------------------+
 *        |
 *        v
 *    +---+----+
 *    |        |
 *    |   1H   |
 *    |        |
 *    +---+----+
 *
 *
 * ~~~
 *
 * This scenario distinguishes between the following types of states:
 * * Top-level (not contained in another hierarchy element representation)
 * * Nested in OR state ("regular" substate)
 * * Nested in AND state (substate of an orthogonal region).
 *
 * For states contained in another state hierarchy element, additionally the distinction is made whether:
 * * The other transition "partner" is a "peer" state in the same container
 * * The other transition "partner" is in another container
 * * The other transition "partner" is in another orthogonal region of the same container (AND states only)
 *
 * The diagram shown above should incorporate all of these types as both incoming and outgoing transition endpoints, as
 * shown by the table below.
 *
 * <html>
 * <table>
 *      <tr>
 *          <th>State situation (↓ to, → from)<br></th>
 *          <th>Top Level</th>
 *          <th colspan="3">Nested in OR state</th>
 *          <th colspan="3">Nested in AND (orthogonal) state</th>
 *      </tr>
 *      <tr>
 *          <td>Top Level</td>
 *          <td>1A→1C</td>
 *          <td colspan="3">1DA→1F</td>
 *          <td colspan="3">1EAB → 1H</td>
 *      </tr>
 *      <tr>
 *          <td rowspan="2">Nested in OR state</td>
 *          <td rowspan="2">1B→1CA<br></td>
 *          <td>Peer</td>
 *          <td colspan="2">In other parent state</td>
 *          <td colspan="3" rowspan="2">1EBA → 1DA</td>
 *      </tr>
 *      <tr>
 *          <td>1CA→1CB<br></td>
 *          <td colspan="2">1CA → 1DA</td>
 *      </tr>
 *      <tr>
 *          <td rowspan="2">Nested in AND (orthogonal) state</td>
 *          <td rowspan="2">1F → 1EBA</td>
 *          <td colspan="3" rowspan="2">1EBA → 1DA<br></td>
 *          <td>Peer</td>
 *          <td>In other <br>orthogonal section <br>of same parent</td>
 *          <td>In other<br>parent<br>state<br></td>
 *      </tr>
 *      <tr>
 *          <td>1EBA → 1EBB</td>
 *          <td>1EAA → 1EBA</td>
 *          <td>1EBB → 1GAA</td>
 *      </tr>
 * </table>
 * </html>
 *
 * The following steps are executed in this scenario:
 * 1. Insert [size] instances of the initial situation as shown above, each situation located right to the previous one.
 * 2. Assert that each situation has been interpreted correctly:
 *     * Every [StateRepresentation] in the situation has been assigned an abstract syntax [State] Element
 *     * The [State.name] is equal to the content of the StateRepresentation's label
 *     * All of the [TransitionRepresentation]s have been converted to Abstract Syntax [Transition] Elements
 *     * Containment for "regular" composite states (OR-States)
 *          * The composite state represented by the [StateRepresentation] xC has a [ParentOf] Relation to the state
 *            by the [StateRepresentation]s xCA and xCB
 *          * The composite state represented by the [StateRepresentation] xD has a [ParentOf] Relation to the state
 *            by the [StateRepresentation]s xDA
 *     * Containment for orthogonal regions:
 *          * The orthogonal region represented by the left compartment of the StateRepresentation xE contains the
 *            Abstract Syntax [State] Elements represented by the [StateRepresentation]s xEAA and xEAB
 *          * The orthogonal region represented by the right compartment of the StateRepresentation xE contains the
 *            Abstract Syntax [State] Elements represented by the [StateRepresentation]s xEBA and xEBB
 *          * The orthogonal region represented by the left compartment of the StateRepresentation xG contains the
 *            Abstract Syntax [State] Element represented by the [StateRepresentation] xGAA
 *          * The orthogonal region represented by the right compartment of the StateRepresentation xG contains the
 *            Abstract Syntax [State] Element represented by the [StateRepresentation] xGBA
 *
 * The following steps are all executed within situation 1, to simulate the user making changes to the diagram
 *
 * 3. Move the State Representation 1CB into the interior of 1D, while adapting its attached connection lines to still
 *    point to that new direction
 *
 * 4. Assert that:
 *     * The composite state represented by [StateRepresentation] 1D now has [ParentOf] Relations towards the states
 *       represented by 1DA and 1CB
 *     * Both the transitions 1CA → 1CB as well as 1CB → 1EAA have stayed in the abstract syntax model; they also still
 *       have the same ID
 *
 * The following steps are designed so that every of the three categories of states (columns/rows of the table above)
 * is an endpoint of the transition once.
 *
 * 5. Insert a new Transition Representation 1EBA → 1EBB.
 *    The purpose of this is to check if:
 *    * Inserting Transition lines connecting already present State Representations will create the [Transition]
 *      abstract syntax Elements
 *    * Transitions between States of the same containing Element are correctly interpreted
 *
 * 6. Assert that the correct Abstract Syntax [Transition] Element has been created for step 5
 *
 * 7. Modify the transition representation from step 5 to now connect 1EBA → 1G (with the same ID for the Line GraphicObject).
 *    The purpose of this is to check if:
 *     * Updates in line position correctly modify the transitions in abstract syntax
 *     * Transitions to a state are correctly inserted even if that state contains orthogonal regions (which may never
 *       be the source or target of Transitions)
 *
 * 8. Assert that a new Abstract Syntax [Transition] Element has been inserted connecting the [State]s represented by
 *    1EBA and 1G
 *
 * 9. Assert that in Abstract Syntax, a [Transition] relation between the States represented by 1EBA and 1EBB does no
 *    longer exist
 *
 * 10. Again move the line from step 6 so that it now connects 1EBA → 1CB
 *
 * 11. Assert that a new Abstract Syntax [Transition] Element has been inserted connecting the [State]s represented by
 *    1EBA and 1CB
 *
 * 12. Assert that in Abstract Syntax, a [Transition] relation between the States represented by 1EBA and 1G does no
 *    longer exist
 *
 * 13. Move the transition representation which would previously connect 1B → 1CA so that it is below 1H (dangling
 *     transition).
 *     The purpose of this is to check if:
 *       * Existing [Transition] Relations are removed on move of representing Lines even if no new Transition is
 *         instantly created
 *       * The system can handle dangling edges respectively that the endpoint is inserted after the edge, without
 *         moving the latter.
 *
 * 14. Assert that the line moved in step 13 no longer has any [Represents] relations attached to it, and that there
 *     is no longer an Abstract Syntax [Transition] Element between states 1B → 1CA
 *
 * 15. Insert a new State Representation 1I below the line from step 14
 *
 * 16. Assert that now, an Abstract Syntax [Transition] relation exists between the states represented by 1H and 1I.
 *
 */
@Suppress("unused", "FunctionName")
class OrthogonalHierarchyConnectionTest(val size: Int) : BaseStatechartScenario() {
    override val testInstanceInfo: TestInstanceInfo = TestInstanceInfo(
            "OHCT",
            "OrthogonalHierarchyConnectionTest; $size situations",
            OrthogonalHierarchyConnectionTestDetails(
                    size,
                    size * 17,
                    size * 12,
                    size * 4
            )
    )

    override val systemTestProcessor by disposableLazy {
        SystemTestProcessor(listOf(
                StateChartAbstractSyntaxElement::class.java,
                LabelFor::class.java,
                Represents::class.java,
                CompartmentHotSpotDefinition::class.java
        ))
    }

    /**
     * Margin spacing left to all sides of a state representation.
     */
    private val stateMargin: Double = 30.0

    /**
     * The distance that should be kept between two states that are directly related
     */
    private val connectedStateReprDistance: Double = 2 * stateMargin

    private val minStateRepresentationWidth: Double = 100.0

    private val minStateRepresentationHeight: Double = 100.0

    private val labelHeight: Double = 20.0

    private val roundedEdgeSize = 10.0

    /**
     * Distance that all compartment-splitting lines should have from the outer border of their Area.
     */
    private val compartmentLineMargin: Double = 3.0

    private val connectionEndDistance: Double = 5.0

    private val stateRepresentationGenerator by disposableLazy {
        StateRepresentationGenerator(roundedEdgeSize)
    }

    private val compartmentLineGenerator by disposableLazy {
        SplittingOrthogonalStateLineGenerator(compartmentLineMargin)
    }

    private val stateTransitionGenerator by disposableLazy {
        StateTransitionGenerator(connectionEndDistance, listOf(-1))
    }

    private val situations by disposableLazy {
        (1..size).map { generateHierarchicalStateSituationWithTransitions(it) }
    }

    private val firstSituation by disposableLazy {
        situations.first()
    }

    @CouchEditSuiteTest
    @Order(1)
    fun `insert all hierarchical state situations with connections`() {
        val inputDiffCollection = testDiffCollectionFactory.createMutableTimedDiffCollection()

        var stateCount = 0
        var transitionCount = 0

        for (situation in situations) {
            stateCount += situation.stateRepresentations.size
            transitionCount += situation.transitionRepresentations.size()

            storeAll(situation.getAllElements(), inputDiffCollection)
        }

        pt(
                inputDiffCollection,
                OrthogonalHierarchyConnectionTest::`insert all hierarchical state situations with connections`,
                "Insert $stateCount states, $transitionCount transitions"
        )
    }

    @CouchEditSuiteTest
    @Order(2)
    fun `should have correctly interpreted all situations`() {
        for (situation in situations) {
            assertInitialSituationInterpretedCorrectly(situation)
        }
    }

    private lateinit var caToCbTransitionId: String
    private lateinit var cbToEaaTransitionId: String

    /**
     * Move the "CB" state to the right into the area of the "D" state, but take the transitions with it
     *
     * ~~~
     * +--------+   +--------+
     * |        |   |        |
     * |   1A   |   |   1B   |
     * |        |   |        |
     * +--+-----+ +-+--------+
     *    |       |
     *    v       |
     * +--+----------+   +--------------+
     * |  1C      |  |   | 1D           |
     * |          v  |   |              |
     * |  +-------++ |   |  +---------+ |
     * |  |        | |   |  |         | |
     * |  |  1CA   +------->+   1DA   +----------+
     * |  |        | |   |  |         | |        |
     * |  +----+---+ |   |  +-+-------+ |        |
     * |       |     |   |    ^         |        |
     * |       |     |   |    |         |        |
     * |       |     |   |  +--------+  |        |
     * |       +----------->+ |      |  |        |
     * |             |   |  | |1CB   |  |        |
     * |             |   |  | |      |  |        v
     * |      +-------------+--------+  |     +--+-----+
     * |      |      |   |    |         |     |        |
     * +-------------+   +--------------+     |   1F   |
     *        |               |               |        |
     *        |               |               +--+-----+
     * +--------------------------------+        |
     * | 1EA  |       X       | 1EB     |        |
     * |      v               |         |        |
     * |  +---+----+  X   +---+----+    |        |
     * |  |        |      |        |    |        |
     * |  |  1EAA  +----->+  1EBA  +<------------+
     * |  |        |      |        |    |
     * |  +---+----+  X   +--------+    |    +-----------------------+
     * |      |                         |    | 1GA       X  1GB      |
     * |      v       X                 |    |                       |
     * |  +---+----+      +--------+    |    |  +------+ X  +------+ |
     * |  |        |  X   |        |    |    |  |      |    |      | |
     * |  |  1EAB  |      |  1EBB  +----------->+ 1GAA | X  | 1GBA | |
     * |  |        |  X   |        |    |    |  |      |    |      | |
     * |  +---+----+      +--------+    |    |  +------+ X  +------+ |
     * |      |       X                 |    |                       |
     * +--------------------------------+    +-----------------------+
     *        |
     *        v
     *    +---+----+
     *    |        |
     *    |   1H   |
     *    |        |
     *    +--------+
     * ~~~
     */
    @CouchEditSuiteTest
    @Order(3)
    fun `move state representation 1CB to the interior of 1D`() {
        val caId = firstSituation.idOf("CA")
        val cbId = firstSituation.idOf("CB")
        val daId = firstSituation.idOf("DA")
        val eaaId = firstSituation.idOf("EAA")

        val caStateRepr = firstSituation.stateRepresentations.getValue(caId)
        val cbStateRepr = firstSituation.stateRepresentations.getValue(cbId)
        val daStateRepr = firstSituation.stateRepresentations.getValue(daId)
        val eaaStateRepr = firstSituation.stateRepresentations.getValue(eaaId)

        val cbStateReprNew = stateRepresentationGenerator.getStateRepresentationFrom(
                Area(
                        daStateRepr.outerStateArea.x,
                        cbStateRepr.outerStateArea.y,
                        cbStateRepr.outerStateArea.w,
                        cbStateRepr.outerStateArea.h
                ),
                cbStateRepr
        )

        firstSituation.stateRepresentations[cbId] = cbStateReprNew

        val transitionCAtoCB = getTransitionRepresentedBy(firstSituation.transitionRepresentations.get(caId, cbId)!!)
        val transitionCBtoEAA = getTransitionRepresentedBy(firstSituation.transitionRepresentations.get(cbId, eaaId)!!)

        caToCbTransitionId = transitionCAtoCB!!.id
        cbToEaaTransitionId = transitionCBtoEAA!!.id

        val newTransitionCAtoCB = stateTransitionGenerator.createConnectionBetween(caStateRepr, cbStateReprNew)
        val newTransitionCBtoEAA = stateTransitionGenerator.createConnectionBetween(cbStateReprNew, eaaStateRepr)

        firstSituation.transitionRepresentations.put(caId, cbId, newTransitionCAtoCB)
        firstSituation.transitionRepresentations.put(cbId, eaaId, newTransitionCBtoEAA)

        val inputDiffCollection = testDiffCollectionFactory.createMutableTimedDiffCollection()

        storeAll(cbStateReprNew, inputDiffCollection)
        storeAll(newTransitionCAtoCB, inputDiffCollection)
        storeAll(newTransitionCBtoEAA, inputDiffCollection)

        pt(
                inputDiffCollection,
                OrthogonalHierarchyConnectionTest::`move state representation 1CB to the interior of 1D`,
                "Move State CB to the inner area of state D"
        )
    }

    @CouchEditSuiteTest
    @Order(4)
    fun `assert that transitions of the state represented by 1CB have stayed intact`() {
        assertCorrectChildrenInSituation(
                firstSituation,
                "D",
                listOf("DA", "CB")
        )

        assertTransitionRepresentationOfSituationInterpretedCorrectly(
                firstSituation,
                firstSituation.idOf("CA"),
                firstSituation.idOf("CB"),
                caToCbTransitionId
        )

        assertTransitionRepresentationOfSituationInterpretedCorrectly(
                firstSituation,
                firstSituation.idOf("CB"),
                firstSituation.idOf("EAA"),
                cbToEaaTransitionId
        )
    }

    private lateinit var ebaId: String
    private lateinit var ebbId: String

    /**
     * ~~~
     * +--------+   +--------+
     * |        |   |        |
     * |   1A   |   |   1B   |
     * |        |   |        |
     * +--+-----+ +-+--------+
     *    |       |
     *    v       |
     * +--+----------+   +--------------+
     * |  1C      |  |   | 1D           |
     * |          v  |   |              |
     * |  +-------++ |   |  +---------+ |
     * |  |        | |   |  |         | |
     * |  |  1CA   +------->+   1DA   +----------+
     * |  |        | |   |  |         | |        |
     * |  +----+---+ |   |  +-+-------+ |        |
     * |       |     |   |    ^         |        |
     * |       |     |   |    |         |        |
     * |       |     |   |  +--------+  |        |
     * |       +----------->+ |      |  |        |
     * |             |   |  | |1CB   |  |        |
     * |             |   |  | |      |  |        v
     * |      +-------------+--------+  |     +--+-----+
     * |      |      |   |    |         |     |        |
     * +-------------+   +--------------+     |   1F   |
     *        |               |               |        |
     *        |               |               +--+-----+
     * +--------------------------------+        |
     * | 1EA  |       X       | 1EB     |        |
     * |      v               |         |        |
     * |  +---+----+  X   +---+----+    |        |
     * |  |        |      |        |    |        |
     * |  |  1EAA  +----->+  1EBA  +<------------+
     * |  |        |      |        |    |
     * |  +---+----+  X   +---+----+    |    +-----------------------+
     * |      |               |         |    | 1GA       X  1GB      |
     * |      v       X       v         |    |                       |
     * |  +---+----+      +---+----+    |    |  +------+ X  +------+ |
     * |  |        |  X   |        |    |    |  |      |    |      | |
     * |  |  1EAB  |      |  1EBB  +----------->+ 1GAA | X  | 1GBA | |
     * |  |        |  X   |        |    |    |  |      |    |      | |
     * |  +---+----+      +--------+    |    |  +------+ X  +------+ |
     * |      |       X                 |    |                       |
     * +--------------------------------+    +-----------------------+
     *        |
     *        v
     *    +---+----+
     *    |        |
     *    |   1H   |
     *    |        |
     *    +--------+
     * ~~~
     */
    @CouchEditSuiteTest
    @Order(5)
    fun `insert a new transition representation between peer states of the same orthogonal region 1EBA and 1EBB`() {
        ebaId = firstSituation.idOf("EBA")
        ebbId = firstSituation.idOf("EBB")

        val eaaRepr = firstSituation.stateRepresentations.getValue(ebaId)
        val eabRepr = firstSituation.stateRepresentations.getValue(ebbId)

        val transitionRepresentation = stateTransitionGenerator.createConnectionBetween(eaaRepr, eabRepr)

        firstSituation.transitionRepresentations.put(ebaId, ebbId, transitionRepresentation)

        val inputDiffCollection = testDiffCollectionFactory.createMutableTimedDiffCollection()

        storeAll(transitionRepresentation, inputDiffCollection)

        pt(
                inputDiffCollection,
                OrthogonalHierarchyConnectionTest::`insert a new transition representation between peer states of the same orthogonal region 1EBA and 1EBB`,
                "Insert a new transitions between $ebaId and $ebbId"
        )
    }

    @CouchEditSuiteTest
    @Order(6)
    fun `should have correctly generated the Abstract Syntax Transition between 1EBA and 1EBB`() {
        assertTransitionRepresentationOfSituationInterpretedCorrectly(firstSituation, ebaId, ebbId)
    }

    private lateinit var gId: String

    /**
     * ~~~
     * +--------+   +--------+
     * |        |   |        |
     * |   1A   |   |   1B   |
     * |        |   |        |
     * +--+-----+ +-+--------+
     *    |       |
     *    v       |
     * +--+----------+   +--------------+
     * |  1C      |  |   | 1D           |
     * |          v  |   |              |
     * |  +-------++ |   |  +---------+ |
     * |  |        | |   |  |         | |
     * |  |  1CA   +------->+   1DA   +----------+
     * |  |        | |   |  |         | |        |
     * |  +----+---+ |   |  +-+-------+ |        |
     * |       |     |   |    ^         |        |
     * |       |     |   |    |         |        |
     * |       |     |   |  +--------+  |        |
     * |       +----------->+ |      |  |        |
     * |             |   |  | |1CB   |  |        |
     * |             |   |  | |      |  |        v
     * |      +-------------+--------+  |     +--+-----+
     * |      |      |   |    |         |     |        |
     * +-------------+   +--------------+     |   1F   |
     *        |               |               |        |
     *        |               |               +--+-----+
     * +--------------------------------+        |
     * | 1EA  |       X       | 1EB     |        |
     * |      v               |         |        |
     * |  +---+----+  X   +---+----+    |        |
     * |  |        |      |        |    |        |
     * |  |  1EAA  +----->+  1EBA  +<------------+
     * |  |        |      |        |    |
     * |  +---+----+  X   +--------+-------->+-----------------------+
     * |      |                         |    | 1GA       X  1GB      |
     * |      v       X                 |    |                       |
     * |  +---+----+      +--------+    |    |  +------+ X  +------+ |
     * |  |        |  X   |        |    |    |  |      |    |      | |
     * |  |  1EAB  |      |  1EBB  +----------->+ 1GAA | X  | 1GBA | |
     * |  |        |  X   |        |    |    |  |      |    |      | |
     * |  +---+----+      +--------+    |    |  +------+ X  +------+ |
     * |      |       X                 |    |                       |
     * +--------------------------------+    +-----------------------+
     *        |
     *        v
     *    +---+----+
     *    |        |
     *    |   1H   |
     *    |        |
     *    +--------+
     * ~~~
     */
    @CouchEditSuiteTest
    @Order(7)
    fun `move line representing transition 1EBA-1EBB to have 1G as its new endpoint`() {
        gId = firstSituation.idOf("G")

        val newTransitionRepresentation1EBAto1G = changeTransitionRepresentationEndPoints(firstSituation, ebaId, ebbId, ebaId, gId)

        val inputDiffCollection = testDiffCollectionFactory.createMutableTimedDiffCollection()

        storeAll(newTransitionRepresentation1EBAto1G, inputDiffCollection)

        pt(
                inputDiffCollection,
                OrthogonalHierarchyConnectionTest::`move line representing transition 1EBA-1EBB to have 1G as its new endpoint`,
                "Move line 1EBA - 1EBB towards 1G"
        )
    }

    @CouchEditSuiteTest
    @Order(8)
    fun `should have correctly generated the Abstract Syntax Transition between 1EBA and 1G`() {
        assertTransitionRepresentationOfSituationInterpretedCorrectly(firstSituation, ebaId, gId)
    }

    @CouchEditSuiteTest
    @Order(9)
    fun `should have removed the Abstract Syntax Transition between 1EBA and 1EBB`() {
        val ebaStateRef = getStateRepresentedBySuffix(firstSituation, "EBA")
        val ebbStateRef = getStateRepresentedBySuffix(firstSituation, "EBB")

        assertNoTransitionBetween(ebaStateRef, ebbStateRef)
    }


    lateinit var cbId: String

    /**
     * ~~~
     * +--------+   +--------+
     * |        |   |        |
     * |   1A   |   |   1B   |
     * |        |   |        |
     * +--+-----+ +-+--------+
     *    |       |
     *    v       |
     * +--+----------+   +--------------+
     * |  1C      |  |   | 1D           |
     * |          v  |   |              |
     * |  +-------++ |   |  +---------+ |
     * |  |        | |   |  |         | |
     * |  |  1CA   +------->+   1DA   +----------+
     * |  |        | |   |  |         | |        |
     * |  +----+---+ |   |  +-+-------+ |        |
     * |       |     |   |    ^         |        |
     * |       |     |   |    |         |        |
     * |       |     |   |  +--------+  |        |
     * |       +----------->+ |      |  |        |
     * |             |   |  | |1CB   |  |        |
     * |             |   |  | |      |  |        v
     * |      +-------------+-----+--+  |     +--+-----+
     * |      |      |   |    |   ^     |     |        |
     * +-------------+   +--------------+     |   1F   |
     *        |               |   |           |        |
     *        |               |   |           +--+-----+
     * +--------------------------------+        |
     * | 1EA  |       X       |   |  1EB|        |
     * |      v               |   |     |        |
     * |  +---+----+  X   +---+---++    |        |
     * |  |        |      |        |    |        |
     * |  |  1EAA  +----->+  1EBA  +<------------+
     * |  |        |      |        |    |
     * |  +---+----+  X   +--------+    |    +-----------------------+
     * |      |                         |    | 1GA       X  1GB      |
     * |      v       X                 |    |                       |
     * |  +---+----+      +--------+    |    |  +------+ X  +------+ |
     * |  |        |  X   |        |    |    |  |      |    |      | |
     * |  |  1EAB  |      |  1EBB  +----------->+ 1GAA | X  | 1GBA | |
     * |  |        |  X   |        |    |    |  |      |    |      | |
     * |  +---+----+      +--------+    |    |  +------+ X  +------+ |
     * |      |       X                 |    |                       |
     * +--------------------------------+    +-----------------------+
     *        |
     *        v
     *    +---+----+
     *    |        |
     *    |   1H   |
     *    |        |
     *    +--------+
     * ~~~
     */
    @CouchEditSuiteTest
    @Order(10)
    fun `move line representing transition 1EBA-1G to have 1CB as its new endpoint`() {
        cbId = firstSituation.idOf("CB")

        val newTransitionRepresentation1EBAto1CB = changeTransitionRepresentationEndPoints(firstSituation, ebaId, gId, ebaId, cbId)

        val inputDiffCollection = testDiffCollectionFactory.createMutableTimedDiffCollection()

        storeAll(newTransitionRepresentation1EBAto1CB, inputDiffCollection)

        pt(
                inputDiffCollection,
                OrthogonalHierarchyConnectionTest::`move line representing transition 1EBA-1G to have 1CB as its new endpoint`,
                "Move line 1EBA - 1G towards 1CB"
        )
    }

    @CouchEditSuiteTest
    @Order(11)
    fun `should have correctly generated the Abstract Syntax Transition between 1EBA and 1CB`() {
        assertTransitionRepresentationOfSituationInterpretedCorrectly(firstSituation, ebaId, cbId)
    }

    @CouchEditSuiteTest
    @Order(12)
    fun `should have removed the Abstract Syntax Transition between 1EBA and 1G`() {
        val ebaStateRef = getStateRepresentedBySuffix(firstSituation, "EBA")
        val gStateRef = getStateRepresentedBySuffix(firstSituation, "G")

        assertNoTransitionBetween(ebaStateRef, gStateRef)
    }

    /**
     * ID of StateRepresentation 1A
     */
    private lateinit var bId: String

    /**
     * ID of StateRepresentation 1CA
     */
    private lateinit var caId: String

    /**
     * ID of StateRepresentation 1H
     */
    private lateinit var hId: String

    /**
     * The [StateRepresentation] that is to be inserted in Step 15.
     */
    private lateinit var stateRepresentationToInsert: StateRepresentation

    /**
     * The [TransitionRepresentation] leading to the state represented by [stateRepresentationToInsert],
     */
    private lateinit var newTransitionRepresentation1Hto1I: TransitionRepresentation

    /**
     * ~~~
     * +--------+   +--------+
     * |        |   |        |
     * |   1A   |   |   1B   |
     * |        |   |        |
     * +--+-----+   +--------+
     *    |
     *    v
     * +--+----------+   +--------------+
     * |  1C         |   | 1D           |
     * |             |   |              |
     * |  +--------+ |   |  +---------+ |
     * |  |        | |   |  |         | |
     * |  |  1CA   +------->+   1DA   +----------+
     * |  |        | |   |  |         | |        |
     * |  +----+---+ |   |  +-+-------+ |        |
     * |       |     |   |    ^         |        |
     * |       |     |   |    |         |        |
     * |       |     |   |  +--------+  |        |
     * |       +----------->+ |      |  |        |
     * |             |   |  | |1CB   |  |        |
     * |             |   |  | |      |  |        v
     * |      +-------------+-----+--+  |     +--+-----+
     * |      |      |   |    |   ^     |     |        |
     * +-------------+   +--------------+     |   1F   |
     *        |               |   |           |        |
     *        |               |   |           +--+-----+
     * +--------------------------------+        |
     * | 1EA  |       X       |   |  1EB|        |
     * |      v               |   |     |        |
     * |  +---+----+  X   +---+---++    |        |
     * |  |        |      |        |    |        |
     * |  |  1EAA  +----->+  1EBA  +<------------+
     * |  |        |      |        |    |
     * |  +---+----+  X   +--------+    |    +-----------------------+
     * |      |                         |    | 1GA       X  1GB      |
     * |      v       X                 |    |                       |
     * |  +---+----+      +--------+    |    |  +------+ X  +------+ |
     * |  |        |  X   |        |    |    |  |      |    |      | |
     * |  |  1EAB  |      |  1EBB  +----------->+ 1GAA | X  | 1GBA | |
     * |  |        |  X   |        |    |    |  |      |    |      | |
     * |  +---+----+      +--------+    |    |  +------+ X  +------+ |
     * |      |       X                 |    |                       |
     * +--------------------------------+    +-----------------------+
     *        |
     *        v
     *    +---+----+
     *    |        |
     *    |   1H   |
     *    |        |
     *    +---+----+
     *        |
     *        |
     *        v
     * ~~~
     */
    @CouchEditSuiteTest
    @Order(13)
    fun `move one transition representation below the diagram`() {
        bId = firstSituation.idOf("B")
        caId = firstSituation.idOf("CA")
        hId = firstSituation.idOf("H")
        val iId = firstSituation.idOf("I")

        val transitionRepresentation1Bto1CA = firstSituation.transitionRepresentations.remove(bId, caId)!!

        val hStateRepr = firstSituation.stateRepresentations.getValue(hId)

        // generate a new state representation below state 1H
        stateRepresentationToInsert = stateRepresentationGenerator.getStateRepresentationFrom(
                Area(
                        hStateRepr.outerStateArea.x,
                        hStateRepr.outerStateArea.bottom + connectedStateReprDistance,
                        minStateRepresentationWidth,
                        minStateRepresentationHeight
                ),
                iId
        )

        newTransitionRepresentation1Hto1I = stateTransitionGenerator.createConnectionBetweenKeepingOldId(
                hStateRepr,
                stateRepresentationToInsert,
                transitionRepresentation1Bto1CA
        )

        val inputDiffCollection = testDiffCollectionFactory.createMutableTimedDiffCollection()

        storeAll(newTransitionRepresentation1Hto1I, inputDiffCollection)

        pt(
                inputDiffCollection,
                OrthogonalHierarchyConnectionTest::`move one transition representation below the diagram`,
                "Move the Line used between 1A and 1CA to the bottom of the diagram"
        )
    }

    @CouchEditSuiteTest
    @Order(14)
    fun `should have removed all transitions represented by the moved line`() {
        val lineId = newTransitionRepresentation1Hto1I.line.id

        val representsTransitionRelations = testModelRepository.getRelationsFromElement(
                lineId,
                Represents::class.java,
                true
        )

        assertThat(representsTransitionRelations).describedAs("The line $lineId should no longer represent a transition")

        val bState = getStateRepresentedBySuffix(firstSituation, "B")
        val caState = getStateRepresentedBySuffix(firstSituation, "CA")

        assertNoTransitionBetween(bState, caState)
    }

    /**
     * ~~~
     * +--------+   +--------+
     * |        |   |        |
     * |   1A   |   |   1B   |
     * |        |   |        |
     * +--+-----+   +--------+
     *    |
     *    v
     * +--+----------+   +--------------+
     * |  1C         |   | 1D           |
     * |             |   |              |
     * |  +--------+ |   |  +---------+ |
     * |  |        | |   |  |         | |
     * |  |  1CA   +------->+   1DA   +----------+
     * |  |        | |   |  |         | |        |
     * |  +----+---+ |   |  +-+-------+ |        |
     * |       |     |   |    ^         |        |
     * |       |     |   |    |         |        |
     * |       |     |   |  +--------+  |        |
     * |       +----------->+ |      |  |        |
     * |             |   |  | |1CB   |  |        |
     * |             |   |  | |      |  |        v
     * |      +-------------+-----+--+  |     +--+-----+
     * |      |      |   |    |   ^     |     |        |
     * +-------------+   +--------------+     |   1F   |
     *        |               |   |           |        |
     *        |               |   |           +--+-----+
     * +--------------------------------+        |
     * | 1EA  |       X       |   |  1EB|        |
     * |      v               |   |     |        |
     * |  +---+----+  X   +---+---++    |        |
     * |  |        |      |        |    |        |
     * |  |  1EAA  +----->+  1EBA  +<------------+
     * |  |        |      |        |    |
     * |  +---+----+  X   +--------+    |    +-----------------------+
     * |      |                         |    | 1GA       X  1GB      |
     * |      v       X                 |    |                       |
     * |  +---+----+      +--------+    |    |  +------+ X  +------+ |
     * |  |        |  X   |        |    |    |  |      |    |      | |
     * |  |  1EAB  |      |  1EBB  +----------->+ 1GAA | X  | 1GBA | |
     * |  |        |  X   |        |    |    |  |      |    |      | |
     * |  +---+----+      +--------+    |    |  +------+ X  +------+ |
     * |      |       X                 |    |                       |
     * +--------------------------------+    +-----------------------+
     *        |
     *        v
     *    +---+----+
     *    |        |
     *    |   1H   |
     *    |        |
     *    +---+----+
     *        |
     *        |
     *        v
     *    +---+----+
     *    |        |
     *    |   1I   |
     *    |        |
     *    +--------+
     * ~~~
     */
    @CouchEditSuiteTest
    @Order(15)
    fun `insert State Representation 1I`() {
        val inputDiffCollection = testDiffCollectionFactory.createMutableTimedDiffCollection()

        firstSituation.transitionRepresentations.put(hId, stateRepresentationToInsert.stateId, newTransitionRepresentation1Hto1I)

        storeAll(stateRepresentationToInsert, inputDiffCollection)

        firstSituation.stateRepresentations[stateRepresentationToInsert.stateId] = stateRepresentationToInsert

        pt(
                inputDiffCollection,
                OrthogonalHierarchyConnectionTest::`insert State Representation 1I`,
                "Insert new State Representation 1I below the line going out from 1H"
        )
    }

    @CouchEditSuiteTest
    @Order(16)
    fun `should have inserted Abstract Syntax transition Element between 1H and 1I`() {
        assertTransitionRepresentationOfSituationInterpretedCorrectly(firstSituation, hId, stateRepresentationToInsert.stateId)
    }


    private fun changeTransitionRepresentationEndPoints(
            situation: OrthogonalHierarchyConnectionSituationRepresentation,
            oldSourceId: String,
            oldTargetId: String,
            newSourceId: String,
            newTargetId: String
    ): TransitionRepresentation {
        val oldTransitionRepr = situation.transitionRepresentations.remove(oldSourceId, oldTargetId)!!

        val newSourceRepr = firstSituation.stateRepresentations.getValue(newSourceId)
        val newTargetRepr = firstSituation.stateRepresentations.getValue(newTargetId)

        val newTransitionRepr = stateTransitionGenerator.createConnectionBetweenKeepingOldId(
                newSourceRepr,
                newTargetRepr,
                oldTransitionRepr
        )

        firstSituation.transitionRepresentations.put(newSourceId, newTargetId, newTransitionRepr)

        return newTransitionRepr
    }


    private fun assertInitialSituationInterpretedCorrectly(situation: OrthogonalHierarchyConnectionSituationRepresentation) {
        for (stateRepr in situation.stateRepresentations.values) {
            val state = getStateRepresentedBy(stateRepr)

            assertThat(state).describedAs(
                    "State Representation ${stateRepr.stateId} should have a State abstract syntax element associated to it, but does not"
            ).isNotNull()

            val label = stateRepr.label

            if (label != null) {
                // We can not check the label directly as with the detection of transitions it cannot be guaranteed that
                // the generated situation always is unambiguous enough. Therefore, check whether the LabelFor
                // relation has been inserted correctly.
                val labelForRelations = testModelRepository.getRelationsBetweenElements(
                        label.id,
                        state!!.id,
                        LabelForHierarchyElement::class.java,
                        true
                )

                assertThat(labelForRelations).describedAs(
                        "Label ${label.id} must have a LabelForHierarchyElement relation towards State element ${state.id}"
                ).isNotEmpty()
            }
        }

        for (transitionCell in situation.transitionRepresentations.cellSet()) {
            assertTransitionRepresentationOfSituationInterpretedCorrectly(situation, transitionCell.rowKey!!, transitionCell.columnKey!!)
        }

        // check parent relations to "normal" states
        assertCorrectChildrenInSituation(situation, "C", listOf("CA", "CB"))
        assertCorrectChildrenInSituation(situation, "D", listOf("DA"))

        // check parent relations to orthogonally split states
        assertCorrectChildrenOfSplitStateInSituation(situation, "E", listOf("EAA", "EAB"), listOf("EBA", "EBB"))
        assertCorrectChildrenOfSplitStateInSituation(situation, "G", listOf("GAA"), listOf("GBA"))
    }

    /**
     * Assert that the State represented by the [StateRepresentation] with the ID suffix [parentSuffix]
     * (for example "A" for 1A, 2A, ...) has a [ParentOf] relation to all of the states represented by the
     * [StateRepresentation]s with the ID suffixes [expectedChildrenSuffixes].
     */
    private fun assertCorrectChildrenInSituation(
            situation: OrthogonalHierarchyConnectionSituationRepresentation,
            parentSuffix: String,
            expectedChildrenSuffixes: Collection<String>
    ) {
        val parentStateRef = getStateRepresentedBySuffix(situation, parentSuffix)

        val childStateRefs = expectedChildrenSuffixes.map {
            getStateRepresentedBySuffix(situation, it)
        }

        assertExactChildren(childStateRefs, parentStateRef)
    }

    private fun assertCorrectChildrenOfSplitStateInSituation(
            situation: OrthogonalHierarchyConnectionSituationRepresentation,
            parentSuffix: String,
            firstChildrenSuffixes: Collection<String>,
            secondChildrenSuffixes: Collection<String>
    ) {
        val parentRepresentationId = situation.idOf(parentSuffix)

        assertThat(situation.stateSplits).containsKey(parentRepresentationId)

        val stateRepr = situation.stateRepresentations[parentRepresentationId]!!

        val compartments = testModelRepository.getRelationsFromElement(
                stateRepr.outerStateRectangle.id,
                CompartmentHotSpotDefinition::class.java,
                true
        )

        assertThat(compartments).describedAs("A vertically split state representation should have exactly 2 compartments").hasSize(2)

        val leftCompartment = compartments.values.find { it.index.indexUL == Pair(0, 0) }!!
        val rightCompartment = compartments.values.find { it.index.indexUL == Pair(1, 0) }!!

        val leftOrthogonalRegion = getOrthogonalStateRepresentedBy(leftCompartment.ref())!!
        val rightOrthogonalRegion = getOrthogonalStateRepresentedBy(rightCompartment.ref())!!

        val firstChildStateRefs = firstChildrenSuffixes.map { getStateRepresentedBySuffix(situation, it) }
        val secondChildStateRefs = secondChildrenSuffixes.map { getStateRepresentedBySuffix(situation, it) }

        assertExactChildren(firstChildStateRefs, leftOrthogonalRegion.ref())
        assertExactChildren(secondChildStateRefs, rightOrthogonalRegion.ref())
    }

    /**
     * Assert that in the context of the given [situation], the TransitionRepresentation which was generated between
     * the [StateRepresentation]s with IDs [fromRepresentationId] and [toRepresentationId] has correctly been assigned
     * a Transition that is represented by the TransitionRepresentation's line.
     */
    private fun assertTransitionRepresentationOfSituationInterpretedCorrectly(
            situation: OrthogonalHierarchyConnectionSituationRepresentation,
            fromRepresentationId: String,
            toRepresentationId: String,
            expectedTransitionId: String? = null
    ) {
        val sourceState = getStateRepresentedBy(situation.stateRepresentations.getValue(fromRepresentationId))
        val targetState = getStateRepresentedBy(situation.stateRepresentations.getValue(toRepresentationId))

        val transitionCellValue = situation.transitionRepresentations.get(fromRepresentationId, toRepresentationId)!!

        val transitions = testModelRepository.getRelationsBetweenElements(
                sourceState!!.id,
                targetState!!.id,
                Transition::class.java,
                true
        )

        expectedTransitionId?.let {
            assertThat(transitions.keys).containsOnlyOnce(expectedTransitionId)
        }

        /**
         * all lines that represent a transition between sourceState and targetState.
         */
        val transitionRepresenters = transitions.flatMap { (id, _) ->
            testModelRepository.getRelationsToElement(
                    id,
                    RepresentsTransition::class.java,
                    true
            ).values.map { it.a }
        }

        // Assert that exactly one transition relation between sourceState and targetState is represented by the
        // generated TransitionRepresentation's line
        assertThat(transitionRepresenters).containsExactly(transitionCellValue.line.ref())
    }

    /**
     * Gets an [ElementReference] to the [State] Abstract Syntax Element which is represented by the
     * [StateRepresentation] with the given [suffix] (e.g. "A") in the given [situation].
     */
    private fun getStateRepresentedBySuffix(situation: OrthogonalHierarchyConnectionSituationRepresentation, suffix: String): ElementReference<State> {
        return getStateRepresentedBy(situation.stateRepresentations.getValue(situation.idOf(suffix)))!!.ref()
    }

    /**
     * Generate an initiol situation (number [xPos]) for the test scenario. For an image of the initial situation,
     * check the main [OrthogonalHierarchyConnectionTest].
     *
     * This is more specifically generated than for other scenarios as the goal of this scenario is to check specific additions and changes in
     * concrete syntax and the speed with which they are handled.
     */
    private fun generateHierarchicalStateSituationWithTransitions(xPos: Int): OrthogonalHierarchyConnectionSituationRepresentation {
        val stateRepresentations = mutableListOf<StateRepresentation>()
        val stateSplits = mutableMapOf<String, SplitResult>()
        val orthogonalRegionLabels = mutableMapOf<String, Pair<Element, Element>>()

        val outerWidth = getSituationOuterWidth()

        val x = xPos * (outerWidth + stateMargin)

        /* ------- Generate top-level state representations ------- */

        val stateRepr1A = stateRepresentationGenerator.getStateRepresentationFrom(
                Area(
                        x,
                        0.0,
                        minStateRepresentationWidth,
                        minStateRepresentationHeight
                ),
                "${xPos}A"
        )

        val stateRepr1B = stateRepresentationGenerator.getStateRepresentationFrom(
                Area(
                        stateRepr1A.outerStateArea.right + stateMargin, // position this to the right of state 1A
                        0.0,
                        minStateRepresentationWidth,
                        minStateRepresentationHeight
                ),
                "${xPos}B"
        )

        val stateRepr1C = stateRepresentationGenerator.getStateRepresentationFrom(
                Area(
                        x,
                        /*
                         * as there will be a direct transition from 1A to 1C, let connectedStateReprDistance between them
                         */
                        stateRepr1A.outerStateArea.bottom + connectedStateReprDistance,
                        /*
                         * leave space for the inner states plus their left / right margins
                         */
                        minStateRepresentationWidth + 2 * stateMargin,
                        /*
                         * Leave space for:
                         * * The inner states 1CA and 1CB
                         * * The label of 1C
                         * * The distance connectedStateReprDistance left vertically between connected states
                         * * One stateMargin below the representation of 1CB
                         */
                        2 * minStateRepresentationHeight + stateMargin + connectedStateReprDistance + labelHeight
                ),
                "${xPos}C",
                StateRepresentationGenerator.LabelPosition.Top(labelHeight)
        )

        val stateRepr1D = stateRepresentationGenerator.getStateRepresentationFrom(
                Area(
                        stateRepr1C.outerStateArea.right + stateMargin,
                        stateRepr1C.outerStateArea.y,
                        stateRepr1C.outerStateArea.w,
                        stateRepr1C.outerStateArea.h
                ),
                "${xPos}D",
                StateRepresentationGenerator.LabelPosition.Top(labelHeight)
        )

        val stateRepr1E = stateRepresentationGenerator.getStateRepresentationFrom(
                Area(
                        x,
                        stateRepr1C.outerStateArea.bottom + stateMargin,
                        /*
                         * Leave space for:
                         * * 4 stateMargins, one to each side of 1EAx and 1EBx
                         * * the width of 1EAx and 1EBx
                         */
                        4 * stateMargin + 2 * minStateRepresentationWidth,
                        /*
                         * Leave space for:
                         * * The inner states 1ExA and 1ExB
                         * * The label of 1Ex
                         * * The distance connectedStateReprDistance left vertically between connected states
                         * * One stateMargin below the representation of 1ExB
                         */
                        2 * minStateRepresentationHeight + stateMargin + connectedStateReprDistance + labelHeight
                ),
                "${xPos}E",
                StateRepresentationGenerator.LabelPosition.None
        )

        val stateRepr1F = stateRepresentationGenerator.getStateRepresentationFrom(
                Area(
                        stateRepr1D.outerStateArea.right + stateMargin,
                        /*
                         * position this aligned with the bottom line of State Representation 1D
                         */
                        stateRepr1D.outerStateArea.bottom - minStateRepresentationHeight,
                        minStateRepresentationWidth,
                        minStateRepresentationHeight
                ),
                "${xPos}F",
                StateRepresentationGenerator.LabelPosition.Center
        )

        /**
         * Height of the representation for state 1G. Precalculated to be able to position it at the bottom border of 1E
         *
         * Leaves space for:
         * * The label of orthogonal states 1Gx
         * * The height of the inner states 1GxA
         * * 1 * [stateMargin] below 1GxA
         */
        val stateRepr1GHeight = labelHeight + minStateRepresentationHeight + stateMargin

        val stateRepr1G = stateRepresentationGenerator.getStateRepresentationFrom(
                Area(
                        stateRepr1E.outerStateArea.right + stateMargin,
                        /*
                         * position this aligned with the bottom line of State Representation 1E
                         */
                        stateRepr1E.outerStateArea.bottom - stateRepr1GHeight,
                        /*
                         * Leave space for:
                         * * 4 stateMargins, one to each side of 1GAA and 1GBA
                         * * the width of 1GAA and 1GBA
                         */
                        4 * stateMargin + 2 * minStateRepresentationWidth,
                        stateRepr1GHeight
                ),
                "${xPos}G",
                StateRepresentationGenerator.LabelPosition.None
        )

        val stateRepr1H = stateRepresentationGenerator.getStateRepresentationFrom(
                Area(
                        x,
                        stateRepr1E.outerStateArea.bottom + stateMargin,
                        minStateRepresentationWidth,
                        minStateRepresentationHeight
                ),
                "${xPos}H",
                StateRepresentationGenerator.LabelPosition.Center
        )

        stateRepresentations.add(stateRepr1A)
        stateRepresentations.add(stateRepr1B)
        stateRepresentations.add(stateRepr1C)
        stateRepresentations.add(stateRepr1D)
        stateRepresentations.add(stateRepr1E)
        stateRepresentations.add(stateRepr1F)
        stateRepresentations.add(stateRepr1G)
        stateRepresentations.add(stateRepr1H)

        /* ------- Generate State representations directly nested in top-level states ------- */

        val stateRepr1CA = stateRepresentationGenerator.getStateRepresentationFrom(
                Area(
                        stateRepr1C.stateInteriorArea!!.x + stateMargin,
                        stateRepr1C.stateInteriorArea.y,
                        minStateRepresentationWidth,
                        minStateRepresentationHeight
                ),
                "${xPos}CA"
        )

        val stateRepr1CB = stateRepresentationGenerator.getStateRepresentationFrom(
                Area(
                        stateRepr1CA.outerStateArea.x,
                        stateRepr1CA.outerStateArea.bottom + connectedStateReprDistance,
                        minStateRepresentationWidth,
                        minStateRepresentationHeight
                ),
                "${xPos}CB"
        )

        val stateRepr1DA = stateRepresentationGenerator.getStateRepresentationFrom(
                Area(
                        stateRepr1D.stateInteriorArea!!.x + stateMargin,
                        stateRepr1D.stateInteriorArea.y,
                        minStateRepresentationWidth,
                        minStateRepresentationHeight
                ),
                "${xPos}DA"
        )

        stateRepresentations.add(stateRepr1CA)
        stateRepresentations.add(stateRepr1CB)
        stateRepresentations.add(stateRepr1DA)

        /* ------- generate OrthogonalRegion representations ------- */

        // For State 1E - regions labeled 1EA and 1EB

        val stateRepr1ESplitResult = compartmentLineGenerator.split(
                "${xPos}E_Split",
                stateRepr1E.outerStateArea,
                OrthogonalStateLineRepresentation.LineOrientation.VERTICAL
        )

        stateSplits[stateRepr1E.stateId] = stateRepr1ESplitResult

        val (orthogonalRegionRepr1EAArea, orthogonalRegionRepr1EBArea) = stateRepr1ESplitResult.areas

        val orthogonalRegionRepr1EALabel = PrimitiveGraphicObject(
                "${xPos}EA_Label",
                Label(
                        orthogonalRegionRepr1EAArea.x + roundedEdgeSize,
                        orthogonalRegionRepr1EAArea.y,
                        orthogonalRegionRepr1EAArea.w - roundedEdgeSize,
                        labelHeight,
                        "OR_${xPos}EA"
                )
        )

        val orthogonalRegionRepr1EBLabel = PrimitiveGraphicObject(
                "${xPos}EB_Label",
                Label(
                        orthogonalRegionRepr1EBArea.x,
                        orthogonalRegionRepr1EBArea.y,
                        orthogonalRegionRepr1EBArea.w - roundedEdgeSize,
                        labelHeight,
                        "OR_${xPos}EB"
                )
        )

        orthogonalRegionLabels[stateRepr1E.stateId] = Pair(orthogonalRegionRepr1EALabel, orthogonalRegionRepr1EBLabel)

        // For State 1G - regions labeled 1GA and 1GB

        val stateRepr1GSplitResult = compartmentLineGenerator.split(
                "${xPos}G_Split",
                stateRepr1G.outerStateArea,
                OrthogonalStateLineRepresentation.LineOrientation.VERTICAL
        )

        stateSplits[stateRepr1G.stateId] = stateRepr1GSplitResult

        val (orthogonalRegionRepr1GAArea, orthogonalRegionRepr1GBArea) = stateRepr1GSplitResult.areas

        val orthogonalRegionRepr1GALabel = PrimitiveGraphicObject(
                "${xPos}GA_Label",
                Label(
                        orthogonalRegionRepr1GAArea.x + roundedEdgeSize,
                        orthogonalRegionRepr1GAArea.y,
                        orthogonalRegionRepr1GAArea.w - roundedEdgeSize,
                        labelHeight,
                        "OR_${xPos}GA"
                )
        )

        val orthogonalRegionRepr1GBLabel = PrimitiveGraphicObject(
                "${xPos}GB_Label",
                Label(
                        orthogonalRegionRepr1GBArea.x,
                        orthogonalRegionRepr1GBArea.y,
                        orthogonalRegionRepr1GBArea.w - roundedEdgeSize,
                        labelHeight,
                        "OR_${xPos}GB"
                )
        )

        orthogonalRegionLabels[stateRepr1G.stateId] = Pair(orthogonalRegionRepr1GALabel, orthogonalRegionRepr1GBLabel)

        /* ------- Generate nested states of OrthogonalRegions of 1E ------- */

        val stateRepr1EAA = stateRepresentationGenerator.getStateRepresentationFrom(
                Area(
                        orthogonalRegionRepr1EAArea.x + stateMargin,
                        orthogonalRegionRepr1EAArea.y + labelHeight, // leave room for 1EA label
                        minStateRepresentationWidth,
                        minStateRepresentationHeight
                ),
                "${xPos}EAA"
        )

        val stateRepr1EAB = stateRepresentationGenerator.getStateRepresentationFrom(
                Area(
                        stateRepr1EAA.outerStateArea.x,
                        stateRepr1EAA.outerStateArea.bottom + connectedStateReprDistance,
                        minStateRepresentationWidth,
                        minStateRepresentationHeight
                ),
                "${xPos}EAB"
        )

        val stateRepr1EBA = stateRepresentationGenerator.getStateRepresentationFrom(
                Area(
                        orthogonalRegionRepr1EBArea.x + stateMargin,
                        orthogonalRegionRepr1EBArea.y + labelHeight, // leave room for 1EB label
                        minStateRepresentationWidth,
                        minStateRepresentationHeight
                ),
                "${xPos}EBA"
        )

        val stateRepr1EBB = stateRepresentationGenerator.getStateRepresentationFrom(
                Area(
                        stateRepr1EBA.outerStateArea.x,
                        stateRepr1EBA.outerStateArea.bottom + connectedStateReprDistance,
                        minStateRepresentationWidth,
                        minStateRepresentationHeight
                ),
                "${xPos}EBB"
        )

        stateRepresentations.add(stateRepr1EAA)
        stateRepresentations.add(stateRepr1EAB)
        stateRepresentations.add(stateRepr1EBA)
        stateRepresentations.add(stateRepr1EBB)

        val stateRepr1GAA = stateRepresentationGenerator.getStateRepresentationFrom(
                Area(
                        orthogonalRegionRepr1GAArea.x + stateMargin,
                        orthogonalRegionRepr1GAArea.y + labelHeight, // leave room for 1GA label
                        minStateRepresentationWidth,
                        minStateRepresentationHeight
                ),
                "${xPos}GAA"
        )

        val stateRepr1GBA = stateRepresentationGenerator.getStateRepresentationFrom(
                Area(
                        orthogonalRegionRepr1GBArea.x + stateMargin,
                        orthogonalRegionRepr1GBArea.y + labelHeight, // leave room for 1GB label
                        minStateRepresentationWidth,
                        minStateRepresentationHeight
                ),
                "${xPos}GBA"
        )

        stateRepresentations.add(stateRepr1GAA)
        stateRepresentations.add(stateRepr1GBA)


        val transitionRepresentations = stateTransitionGenerator.createTransitionTableBetween(listOf(
                stateRepr1A to stateRepr1C,
                stateRepr1B to stateRepr1CA,
                stateRepr1CA to stateRepr1DA,
                stateRepr1CA to stateRepr1CB,
                stateRepr1DA to stateRepr1F,
                stateRepr1F to stateRepr1EBA,
                stateRepr1CB to stateRepr1EAA,
                stateRepr1EAA to stateRepr1EAB,
                stateRepr1EAA to stateRepr1EBA,
                stateRepr1EBA to stateRepr1DA,
                stateRepr1EAB to stateRepr1H,
                stateRepr1EBB to stateRepr1GAA
        ))

        return OrthogonalHierarchyConnectionSituationRepresentation(
                xPos,
                stateRepresentations.map { it.stateId to it }.toMap().toMutableMap(),
                stateSplits,
                orthogonalRegionLabels,
                transitionRepresentations
        )
    }

    /**
     * Gets the width of one Orthogonal Hierarchy Connection Situation.
     *
     * The width of the entire state chart is determined by the bottom part, where orthogonal regions 1EA, 1EB, 1GA and 1GB are located next to each other.
     *
     * There, the width is:
     * * 4 * [stateMargin], two to either side of both 1EA* and 1EB*
     * * 4 * [stateMargin], two to either side of both 1GAA and 1GBA
     * * 1 * [stateMargin] between the containers of (1EA & 1EB) and (1GA & 1GB)
     * * 4 * [minStateRepresentationWidth] for 1EA*, 1EB*, 1GAÁ and 1GBA
     */
    private fun getSituationOuterWidth(): Double {
        return 4 * minStateRepresentationWidth + 9 * stateMargin
    }

    data class OrthogonalHierarchyConnectionSituationRepresentation(
            val index: Int,
            /**
             * Map of the [StateRepresentation.stateId] to the associated StateRepresentation
             */
            val stateRepresentations: MutableMap<String, StateRepresentation>,
            /**
             * Map of the [StateRepresentation.stateId] to the associated
             * [SplitResult] if the state representation with the given ID was split further
             */
            val stateSplits: MutableMap<String, SplitResult>,
            /**
             * If the [StateRepresentation.stateId] is in the [stateSplits] Map, this map contains the Label
             * GraphicObjects for these regions.
             */
            val orthogonalRegionLabels: MutableMap<String, Pair<Element, Element>>,
            /**
             * Table where for each (rowKey, columnKey), the cell content is the concrete syntax representation of the
             * transition of the state with ID == rowKey to that with ID == columnKey.
             */
            val transitionRepresentations: Table<String, String, TransitionRepresentation>
    ) {
        /**
         * Returns all Elements that are relevant to this situation
         */
        fun getAllElements(): Map<String, Element> {
            val stateRepresentationElements = stateRepresentations.flatMap { (_, v) -> v.values }
            val stateSplitElements = stateSplits.flatMap { (_, v) -> v.values }
            val orthogonalRegionLabelElements = orthogonalRegionLabels.flatMap { (_, v) -> v.toList() }
            val transitionRepresentationElements = transitionRepresentations.cellSet().flatMap { it.value!!.values }

            val listAll = stateRepresentationElements + stateSplitElements + orthogonalRegionLabelElements + transitionRepresentationElements

            return listAll.map { it.id to it }.toMap()
        }

        /**
         * Gets the ID of the StateRepresentation with the given suffix in this Situation
         */
        fun idOf(suffix: String) = index.toString() + suffix
    }

    private fun dumpToJTS(): Map<String, String> {

        val shapeJTSGeometryProvider = JTSGeometryProvider(PreparedGeometryFactory())

        val serviceCaller = ServiceCaller(testModelRepository)

        val shapeExtractor = injector.getInstance(ShapeExtractor::class.java)

        val stateGeoms = situations.flatMap {
            it.stateRepresentations.values.map { sr ->
                shapeJTSGeometryProvider.toGeometry(sr.outerStateRectangle.shape)
            }
        }

        val splitLineGeoms = situations.flatMap {
            it.stateSplits.values.map { split ->
                shapeJTSGeometryProvider.toGeometry(split.line.shape)
            }
        }

        val transitionGeoms = situations.flatMap {
            it.transitionRepresentations.cellSet().map { cell ->
                val transRepr = cell.value!!

                return@map shapeJTSGeometryProvider.toGeometry(transRepr.line.shape)
            }
        }

        val hsdGeoms = testModelRepository.getAllIncludingSubTypes(CompartmentHotSpotDefinition::class.java).values.map {
            shapeJTSGeometryProvider.toGeometry(serviceCaller.call(it.ref().asType<ShapedElement<Shape>>(), shapeExtractor::extractShape)!!)
        }

        val geomCollString = fun(input: List<PreparedGeometry>): String = input.joinToString(",", "GEOMETRYCOLLECTION(", ")")

        val stateGeomColl = geomCollString(stateGeoms)

        val splitLineGeomColl = geomCollString(splitLineGeoms)

        val hsdGeomColl = geomCollString(hsdGeoms)

        val transitionGeomColl = geomCollString(transitionGeoms)

        return mapOf(
                "states" to stateGeomColl,
                "splitLines" to splitLineGeomColl,
                "transitions" to transitionGeomColl,
                "HotSpots" to hsdGeomColl
        )
    }
}
