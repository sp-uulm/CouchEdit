package de.uulm.se.couchedit

import com.google.common.collect.Table
import de.uulm.se.couchedit.model.graphic.elements.PrimitiveGraphicObject
import de.uulm.se.couchedit.model.graphic.shapes.Rectangular
import de.uulm.se.couchedit.testsuiteutils.testdata.grid.GridAreasGenerator

class TestObjectGenerator(private val gridAreasGenerator: GridAreasGenerator) {
    /**
     * This generates a grid of Rectangular Elements (as generated by the [shapeGenerator] method)
     * which are arranged in a grid
     * * of width [gridSizeX] (i.e. [gridSizeX] Elements arranged next to each other in every row)
     * * of height [gridSizeY] (i.e. [gridSizeY] Elements arranged below each other in every column)
     * * [objectDistance] units apart, i.e. there is a gap of [objectDistance] between neighboring Elements both in x
     *   and y direction
     *
     * @return [Table] of [PrimitiveGraphicObject]s which are arranged as described.
     *         Note that in the [Table.get] call, x and y are "swapped", i.e. the Y index is the row and
     *         the X index is the column as that makes more sense intuitively. The right way of getting thus
     *         is `get(yPos, xPos)`.
     */
    fun givenAGridOfRectangularGraphicObjects(
            gridSizeX: Int,
            gridSizeY: Int,
            shapeGenerator: (Double, Double, Double, Double) -> Rectangular
    ): Table<Int, Int, PrimitiveGraphicObject<Rectangular>> {
        var idCounter = 0

        return gridAreasGenerator.generateGrid(gridSizeX, gridSizeY) { (x, y, w, h) ->
            val pgo = PrimitiveGraphicObject(idCounter.toString(), shapeGenerator(x, y, w, h))

            idCounter++

            return@generateGrid pgo
        }
    }

}
