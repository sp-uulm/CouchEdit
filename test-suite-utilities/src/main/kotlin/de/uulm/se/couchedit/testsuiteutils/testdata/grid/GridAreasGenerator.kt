package de.uulm.se.couchedit.testsuiteutils.testdata.grid

import com.google.common.collect.HashBasedTable
import com.google.common.collect.Table
import kotlin.math.ceil

class GridAreasGenerator(val objectHeight: Double, val objectWidth: Double, val objectDistance: Double) {
    /**
     * This generates a grid of Elements (as generated by the [generator] method)
     * which are arranged in a grid
     * * of width [gridSizeX] (i.e. [gridSizeX] Elements arranged next to each other in every row)
     * * of height [gridSizeY] (i.e. [gridSizeY] Elements arranged below each other in every column)
     * * [objectDistance] units apart, i.e. there is a gap of [objectDistance] between neighboring Elements both in x
     *   and y direction.
     *
     * Additionally, the Grid will be shifted [xOffset] to the right and [yOffset] to the bottom.
     *
     * @return [Table] of [T] objects which are arranged as described.
     *         Note that in the [Table.get] call, x and y are "swapped", i.e. the Y index is the row and
     *         the X index is the column as that makes more sense intuitively. The right way of getting thus
     *         is `get(yPos, xPos)`.
     */
    fun <T> generateGrid(
            gridSizeX: Int,
            gridSizeY: Int,
            xOffset: Double = 0.0,
            yOffset: Double = 0.0,
            generator: (Area) -> T
    ): Table<Int, Int, T> {
        val ret = HashBasedTable.create<Int, Int, T>()

        for (i in 0 until gridSizeX) {
            for (j in 0 until gridSizeY) {
                val item = getGridElement(i, j, xOffset, yOffset, generator)

                ret.put(j, i, item)
            }
        }

        return ret
    }

    private fun <T> getGridElement(
            posX: Int,
            posY: Int,
            xOffset: Double,
            yOffset: Double,
            generator: (Area) -> T
    ): T {
        val x = posX * (objectWidth + objectDistance) + xOffset
        val y = posY * (objectHeight + objectDistance) + yOffset

        return generator(Area(x, y, objectWidth, objectHeight))
    }

    /**
     * Modifies the [grid] so that the given number of Elements is moved out of its middle to the right of the
     * rightmost elements.
     *
     * The Elements of [grid] are changed in-place and the cell indices are NOT changed during this!
     *
     * @param grid Grid of Elements which are currently ordered by their X-coordinate (column) respectively Y-coordinate
     *             (row).
     * @param numberOfElementsToMove Element count that will be picked from the middle of the grid to be moved.
     * @param getArea Gets the outer area of a [T] Element out of the grid into the canonical [Area] representation
     * @param setArea Sets the coordinates of a [T] Element based on an [Area] representation
     * @return Elements of [grid] which were changed
     */
    fun <T> moveElementsToRightOfGrid(
            grid: Table<Int, Int, T>,
            numberOfElementsToMove: Int,
            getArea: (T) -> Area,
            setArea: (T, Area) -> T
    ): Set<T> {
        val gridSizeX = grid.columnKeySet().size
        val gridSizeY = grid.rowKeySet().size

        val numberOfColumnsToMove = ceil(numberOfElementsToMove.toDouble() / gridSizeY).toInt()

        // determine the first Element column that should be moved
        val firstColumnToMove = (gridSizeX - numberOfColumnsToMove) / 2

        if (firstColumnToMove < 0 || numberOfColumnsToMove > gridSizeX) {
            throw RuntimeException("Cannot move $numberOfElementsToMove Elements in a $gridSizeX x $gridSizeY grid")
        }

        // get an element from the leftmost column to be moved
        val firstColumnElement = grid.column(firstColumnToMove).values.first()
        val firstColumnArea = getArea(firstColumnElement)

        // get an element that is in the right border of the grid
        val rightMostElement = grid.column(gridSizeX - 1).values.first()
        val rightMostArea = getArea(rightMostElement)

        val targetX = rightMostArea.x + rightMostArea.w + objectDistance

        val xDifference = targetX - firstColumnArea.x

        // now, move all selected Elements by the x difference
        var currentColumn = firstColumnToMove
        var currentRow = 0

        val ret = mutableSetOf<T>()

        for (i in 0 until numberOfElementsToMove) {
            val element = grid.get(currentRow, currentColumn)
            val area = getArea(element)

            val newX = area.x + xDifference

            val newArea = with(area) { Area(newX, y, w, h) }

            grid.put(currentRow, currentColumn, setArea(element, newArea))

            ret.add(element)

            currentRow++

            if (currentRow >= gridSizeY) {
                currentRow = 0
                currentColumn++
            }
        }

        return ret
    }

    companion object {
        /**
         * Shrinks the given [area] by the given [marginSize] at all four edges.
         */
        fun reduceAreaByMargin(area: Area, marginSize: Double): Area {
            return with(area) {
                check(w > 2 * marginSize && h > 2 * marginSize) {
                    "Cannot insert margin of size $marginSize " +
                            "to Area with width = $w and height = $h"
                }

                Area(x + marginSize, y + marginSize, w - 2 * marginSize, h - 2 * marginSize)
            }
        }
    }

    data class Area(val x: Double, val y: Double, val w: Double, val h: Double) {
        val bottom
            get() = y + h

        val right
            get() = x + w
    }
}
